/**
 *Submitted for verification at Etherscan.io on 2018-10-06
*/pragmasolidity^0.4.23;contractToken{/// total amount of tokensuint256publictotalSupply;/// @param _owner The address from which the balance will be retrieved/// @return The balancefunctionbalanceOf(address_owner)publicconstantreturns(uint256balance);/// @notice send `_value` token to `_to` from `msg.sender`/// @param _to The address of the recipient/// @param _value The amount of token to be transferred/// @return Whether the transfer was successful or notfunctiontransfer(address_to,uint256_value)publicreturns(boolsuccess);/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`/// @param _from The address of the sender/// @param _to The address of the recipient/// @param _value The amount of token to be transferred/// @return Whether the transfer was successful or notfunctiontransferFrom(address_from,address_to,uint256_value)publicreturns(boolsuccess);/// @notice `msg.sender` approves `_spender` to spend `_value` tokens/// @param _spender The address of the account able to transfer the tokens/// @param _value The amount of tokens to be approved for transfer/// @return Whether the approval was successful or notfunctionapprove(address_spender,uint256_value)publicreturns(boolsuccess);/// @param _owner The address of the account owning tokens/// @param _spender The address of the account able to transfer the tokens/// @return Amount of remaining tokens allowed to spentfunctionallowance(address_owner,address_spender)publicconstantreturns(uint256remaining);eventTransfer(addressindexed_from,addressindexed_to,uint256_value);eventApproval(addressindexed_owner,addressindexed_spender,uint256_value);}libraryECTools{functionrecoverSigner(bytes32_hashedMsg,string_sig)publicpurereturns(address){require(_hashedMsg!=0x00);bytesmemoryprefix="\x19Ethereum Signed Message:\n32";bytes32prefixedHash=keccak256(abi.encodePacked(prefix,_hashedMsg));if(bytes(_sig).length!=132){return0x0;}bytes32r;bytes32s;uint8v;bytesmemorysig=hexstrToBytes(substring(_sig,2,132));if(v<27){v+=27;}if(v<27||v>28){return0x0;}returnecrecover(prefixedHash,v,r,s);}functionisSignedBy(bytes32_hashedMsg,string_sig,address_addr)publicpurereturns(bool){require(_addr!=0x0);return_addr==recoverSigner(_hashedMsg,_sig);}functionhexstrToBytes(string_hexstr)publicpurereturns(bytes){uintlen=bytes(_hexstr).length;require(len%2==0);bytesmemorybstr=bytes(newstring(len/2));uintk=0;stringmemorys;stringmemoryr;for(uinti=0;i<len;i+=2){s=substring(_hexstr,i,i+1);r=substring(_hexstr,i+1,i+2);uintp=parseInt16Char(s)*16+parseInt16Char(r);bstr[k++]=uintToBytes32(p)[31];}returnbstr;}functionparseInt16Char(string_char)publicpurereturns(uint){bytesmemorybresult=bytes(_char);if((bresult[0]>=48)&&(bresult[0]<=57)){returnuint(bresult[0])-48;}elseif((bresult[0]>=65)&&(bresult[0]<=70)){returnuint(bresult[0])-55;}elseif((bresult[0]>=97)&&(bresult[0]<=102)){returnuint(bresult[0])-87;}else{revert();}}functionuintToBytes32(uint_uint)publicpurereturns(bytesb){b=newbytes(32);}functiontoEthereumSignedMessage(string_msg)publicpurereturns(bytes32){uintlen=bytes(_msg).length;require(len>0);bytesmemoryprefix="\x19Ethereum Signed Message:\n";returnkeccak256(abi.encodePacked(prefix,uintToString(len),_msg));}functionuintToString(uint_uint)publicpurereturns(stringstr){uintlen=0;uintm=_uint+0;while(m!=0){len++;m/=10;}bytesmemoryb=newbytes(len);uinti=len-1;while(_uint!=0){uintremainder=_uint%10;_uint=_uint/10;b[i--]=byte(48+remainder);}str=string(b);}functionsubstring(string_str,uint_startIndex,uint_endIndex)publicpurereturns(string){bytesmemorystrBytes=bytes(_str);require(_startIndex<=_endIndex);require(_startIndex>=0);require(_endIndex<=strBytes.length);bytesmemoryresult=newbytes(_endIndex-_startIndex);for(uinti=_startIndex;i<_endIndex;i++){result[i-_startIndex]=strBytes[i];}returnstring(result);}}contractStandardTokenisToken{functiontransfer(address_to,uint256_value)publicreturns(boolsuccess){require(balances[msg.sender]>=_value);balances[msg.sender]-=_value;balances[_to]+=_value;emitTransfer(msg.sender,_to,_value);returntrue;}functiontransferFrom(address_from,address_to,uint256_value)publicreturns(boolsuccess){require(balances[_from]>=_value&&allowed[_from][msg.sender]>=_value);balances[_to]+=_value;balances[_from]-=_value;allowed[_from][msg.sender]-=_value;emitTransfer(_from,_to,_value);returntrue;}functionbalanceOf(address_owner)publicconstantreturns(uint256balance){returnbalances[_owner];}functionapprove(address_spender,uint256_value)publicreturns(boolsuccess){allowed[msg.sender][_spender]=_value;emitApproval(msg.sender,_spender,_value);returntrue;}functionallowance(address_owner,address_spender)publicconstantreturns(uint256remaining){returnallowed[_owner][_spender];}mapping(address=>uint256)balances;mapping(address=>mapping(address=>uint256))allowed;}contractHumanStandardTokenisStandardToken{stringpublicname;uint8publicdecimals;stringpublicsymbol;stringpublicversion='H0.1';constructor(uint256_initialAmount,string_tokenName,uint8_decimalUnits,string_tokenSymbol)public{balances[msg.sender]=_initialAmount;totalSupply=_initialAmount;name=_tokenName;decimals=_decimalUnits;symbol=_tokenSymbol;}functionapproveAndCall(address_spender,uint256_value,bytes_extraData)publicreturns(boolsuccess){allowed[msg.sender][_spender]=_value;emitApproval(msg.sender,_spender,_value);require(_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))),msg.sender,_value,this,_extraData));returntrue;}}contractLedgerChannel{stringpublicconstantNAME="Ledger Channel";stringpublicconstantVERSION="0.0.1";uint256publicnumChannels=0;eventDidLCOpen(bytes32indexedchannelId,addressindexedpartyA,addressindexedpartyI,uint256ethBalanceA,addresstoken,uint256tokenBalanceA,uint256LCopenTimeout);eventDidLCJoin(bytes32indexedchannelId,uint256ethBalanceI,uint256tokenBalanceI);eventDidLCDeposit(bytes32indexedchannelId,addressindexedrecipient,uint256deposit,boolisToken);eventDidLCUpdateState(bytes32indexedchannelId,uint256sequence,uint256numOpenVc,uint256ethBalanceA,uint256tokenBalanceA,uint256ethBalanceI,uint256tokenBalanceI,bytes32vcRoot,uint256updateLCtimeout);eventDidLCClose(bytes32indexedchannelId,uint256sequence,uint256ethBalanceA,uint256tokenBalanceA,uint256ethBalanceI,uint256tokenBalanceI);eventDidVCInit(bytes32indexedlcId,bytes32indexedvcId,bytesproof,uint256sequence,addresspartyA,addresspartyB,uint256balanceA,uint256balanceB);eventDidVCSettle(bytes32indexedlcId,bytes32indexedvcId,uint256updateSeq,uint256updateBalA,uint256updateBalB,addresschallenger,uint256updateVCtimeout);eventDidVCClose(bytes32indexedlcId,bytes32indexedvcId,uint256balanceA,uint256balanceB);structChannel{address[2]partyAddresses;uint256[4]ethBalances;uint256[4]erc20Balances;uint256[2]initialDeposit;uint256sequence;uint256confirmTime;bytes32VCrootHash;uint256LCopenTimeout;uint256updateLCtimeout;boolisOpen;boolisUpdateLCSettling;uint256numOpenVC;HumanStandardTokentoken;}structVirtualChannel{boolisClose;boolisInSettlementState;uint256sequence;addresschallenger;uint256updateVCtimeout;addresspartyA;addresspartyB;addresspartyI;uint256[2]ethBalances;uint256[2]erc20Balances;uint256[2]bond;HumanStandardTokentoken;}mapping(bytes32=>VirtualChannel)publicvirtualChannels;mapping(bytes32=>Channel)publicChannels;functioncreateChannel(bytes32_lcID,address_partyI,uint256_confirmTime,address_token,uint256[2]_balances)publicpayable{require(Channels[_lcID].partyAddresses[0]==address(0),"Channel has already been created.");require(_partyI!=0x0,"No partyI address provided to LC creation");require(_balances[0]>=0&&_balances[1]>=0,"Balances cannot be negative");Channels[_lcID].partyAddresses[0]=msg.sender;Channels[_lcID].partyAddresses[1]=_partyI;if(_balances[0]!=0){require(msg.value==_balances[0],"Eth balance does not match sent value");Channels[_lcID].ethBalances[0]=msg.value;}if(_balances[1]!=0){Channels[_lcID].token=HumanStandardToken(_token);require(Channels[_lcID].token.transferFrom(msg.sender,this,_balances[1]),"CreateChannel: token transfer failure");Channels[_lcID].erc20Balances[0]=_balances[1];}Channels[_lcID].sequence=0;Channels[_lcID].confirmTime=_confirmTime;Channels[_lcID].LCopenTimeout=now+_confirmTime;Channels[_lcID].initialDeposit=_balances;emitDidLCOpen(_lcID,msg.sender,_partyI,_balances[0],_token,_balances[1],Channels[_lcID].LCopenTimeout);}functionLCOpenTimeout(bytes32_lcID)public{require(msg.sender==Channels[_lcID].partyAddresses[0]&&Channels[_lcID].isOpen==false);require(now>Channels[_lcID].LCopenTimeout);if(Channels[_lcID].initialDeposit[0]!=0){Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);}if(Channels[_lcID].initialDeposit[1]!=0){require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0],Channels[_lcID].erc20Balances[0]),"CreateChannel: token transfer failure");}emitDidLCClose(_lcID,0,Channels[_lcID].ethBalances[0],Channels[_lcID].erc20Balances[0],0,0);deleteChannels[_lcID];}functionjoinChannel(bytes32_lcID,uint256[2]_balances)publicpayable{require(Channels[_lcID].isOpen==false);require(msg.sender==Channels[_lcID].partyAddresses[1]);if(_balances[0]!=0){require(msg.value==_balances[0],"state balance does not match sent value");Channels[_lcID].ethBalances[1]=msg.value;}if(_balances[1]!=0){require(Channels[_lcID].token.transferFrom(msg.sender,this,_balances[1]),"joinChannel: token transfer failure");Channels[_lcID].erc20Balances[1]=_balances[1];}Channels[_lcID].initialDeposit[0]+=_balances[0];Channels[_lcID].initialDeposit[1]+=_balances[1];Channels[_lcID].isOpen=true;numChannels++;emitDidLCJoin(_lcID,_balances[0],_balances[1]);}functiondeposit(bytes32_lcID,addressrecipient,uint256_balance,boolisToken)publicpayable{require(Channels[_lcID].isOpen==true,"Tried adding funds to a closed channel");require(recipient==Channels[_lcID].partyAddresses[0]||recipient==Channels[_lcID].partyAddresses[1]);if(Channels[_lcID].partyAddresses[0]==recipient){if(isToken){require(Channels[_lcID].token.transferFrom(msg.sender,this,_balance),"deposit: token transfer failure");Channels[_lcID].erc20Balances[2]+=_balance;}else{require(msg.value==_balance,"state balance does not match sent value");Channels[_lcID].ethBalances[2]+=msg.value;}}if(Channels[_lcID].partyAddresses[1]==recipient){if(isToken){require(Channels[_lcID].token.transferFrom(msg.sender,this,_balance),"deposit: token transfer failure");Channels[_lcID].erc20Balances[3]+=_balance;}else{require(msg.value==_balance,"state balance does not match sent value");Channels[_lcID].ethBalances[3]+=msg.value;}}emitDidLCDeposit(_lcID,recipient,_balance,isToken);}functionconsensusCloseChannel(bytes32_lcID,uint256_sequence,uint256[4]_balances,string_sigA,string_sigI)public{require(Channels[_lcID].isOpen==true);uint256totalEthDeposit=Channels[_lcID].initialDeposit[0]+Channels[_lcID].ethBalances[2]+Channels[_lcID].ethBalances[3];uint256totalTokenDeposit=Channels[_lcID].initialDeposit[1]+Channels[_lcID].erc20Balances[2]+Channels[_lcID].erc20Balances[3];require(totalEthDeposit==_balances[0]+_balances[1]);require(totalTokenDeposit==_balances[2]+_balances[3]);bytes32_state=keccak256(abi.encodePacked(_lcID,true,_sequence,uint256(0),bytes32(0x0),Channels[_lcID].partyAddresses[0],Channels[_lcID].partyAddresses[1],_balances[0],_balances[1],_balances[2],_balances[3]));require(Channels[_lcID].partyAddresses[0]==ECTools.recoverSigner(_state,_sigA));require(Channels[_lcID].partyAddresses[1]==ECTools.recoverSigner(_state,_sigI));Channels[_lcID].isOpen=false;if(_balances[0]!=0||_balances[1]!=0){Channels[_lcID].partyAddresses[0].transfer(_balances[0]);Channels[_lcID].partyAddresses[1].transfer(_balances[1]);}if(_balances[2]!=0||_balances[3]!=0){require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0],_balances[2]),"happyCloseChannel: token transfer failure");require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1],_balances[3]),"happyCloseChannel: token transfer failure");}numChannels--;emitDidLCClose(_lcID,_sequence,_balances[0],_balances[1],_balances[2],_balances[3]);}functionupdateLCstate(bytes32_lcID,uint256[6]updateParams,bytes32_VCroot,string_sigA,string_sigI)public{Channelstoragechannel=Channels[_lcID];require(channel.isOpen);require(channel.sequence<updateParams[0]);require(channel.ethBalances[0]+channel.ethBalances[1]>=updateParams[2]+updateParams[3]);require(channel.erc20Balances[0]+channel.erc20Balances[1]>=updateParams[4]+updateParams[5]);if(channel.isUpdateLCSettling==true){require(channel.updateLCtimeout>now);}bytes32_state=keccak256(abi.encodePacked(_lcID,false,updateParams[0],updateParams[1],_VCroot,channel.partyAddresses[0],channel.partyAddresses[1],updateParams[2],updateParams[3],updateParams[4],updateParams[5]));require(channel.partyAddresses[0]==ECTools.recoverSigner(_state,_sigA));require(channel.partyAddresses[1]==ECTools.recoverSigner(_state,_sigI));channel.sequence=updateParams[0];channel.numOpenVC=updateParams[1];channel.ethBalances[0]=updateParams[2];channel.ethBalances[1]=updateParams[3];channel.erc20Balances[0]=updateParams[4];channel.erc20Balances[1]=updateParams[5];channel.VCrootHash=_VCroot;channel.isUpdateLCSettling=true;channel.updateLCtimeout=now+channel.confirmTime;emitDidLCUpdateState(_lcID,updateParams[0],updateParams[1],updateParams[2],updateParams[3],updateParams[4],updateParams[5],_VCroot,channel.updateLCtimeout);}functioninitVCstate(bytes32_lcID,bytes32_vcID,bytes_proof,address_partyA,address_partyB,uint256[2]_bond,uint256[4]_balances,stringsigA)public{require(Channels[_lcID].isOpen,"LC is closed.");require(!virtualChannels[_vcID].isClose,"VC is closed.");require(Channels[_lcID].updateLCtimeout<now,"LC timeout not over.");require(virtualChannels[_vcID].updateVCtimeout==0);bytes32_initState=keccak256(abi.encodePacked(_vcID,uint256(0),_partyA,_partyB,_bond[0],_bond[1],_balances[0],_balances[1],_balances[2],_balances[3]));require(_partyA==ECTools.recoverSigner(_initState,sigA));require(_isContained(_initState,_proof,Channels[_lcID].VCrootHash)==true);virtualChannels[_vcID].partyA=_partyA;virtualChannels[_vcID].partyB=_partyB;virtualChannels[_vcID].sequence=uint256(0);virtualChannels[_vcID].ethBalances[0]=_balances[0];virtualChannels[_vcID].ethBalances[1]=_balances[1];virtualChannels[_vcID].erc20Balances[0]=_balances[2];virtualChannels[_vcID].erc20Balances[1]=_balances[3];virtualChannels[_vcID].bond=_bond;virtualChannels[_vcID].updateVCtimeout=now+Channels[_lcID].confirmTime;virtualChannels[_vcID].isInSettlementState=true;emitDidVCInit(_lcID,_vcID,_proof,uint256(0),_partyA,_partyB,_balances[0],_balances[1]);}functionsettleVC(bytes32_lcID,bytes32_vcID,uint256updateSeq,address_partyA,address_partyB,uint256[4]updateBal,stringsigA)public{require(Channels[_lcID].isOpen,"LC is closed.");require(!virtualChannels[_vcID].isClose,"VC is closed.");require(virtualChannels[_vcID].sequence<updateSeq,"VC sequence is higher than update sequence.");require(virtualChannels[_vcID].ethBalances[1]<updateBal[1]&&virtualChannels[_vcID].erc20Balances[1]<updateBal[3],"State updates may only increase recipient balance.");require(virtualChannels[_vcID].bond[0]==updateBal[0]+updateBal[1]&&virtualChannels[_vcID].bond[1]==updateBal[2]+updateBal[3],"Incorrect balances for bonded amount");require(Channels[_lcID].updateLCtimeout<now);bytes32_updateState=keccak256(abi.encodePacked(_vcID,updateSeq,_partyA,_partyB,virtualChannels[_vcID].bond[0],virtualChannels[_vcID].bond[1],updateBal[0],updateBal[1],updateBal[2],updateBal[3]));require(virtualChannels[_vcID].partyA==ECTools.recoverSigner(_updateState,sigA));virtualChannels[_vcID].challenger=msg.sender;virtualChannels[_vcID].sequence=updateSeq;virtualChannels[_vcID].ethBalances[0]=updateBal[0];virtualChannels[_vcID].ethBalances[1]=updateBal[1];virtualChannels[_vcID].erc20Balances[0]=updateBal[2];virtualChannels[_vcID].erc20Balances[1]=updateBal[3];virtualChannels[_vcID].updateVCtimeout=now+Channels[_lcID].confirmTime;emitDidVCSettle(_lcID,_vcID,updateSeq,updateBal[0],updateBal[1],msg.sender,virtualChannels[_vcID].updateVCtimeout);}functioncloseVirtualChannel(bytes32_lcID,bytes32_vcID)public{require(Channels[_lcID].isOpen,"LC is closed.");require(virtualChannels[_vcID].isInSettlementState,"VC is not in settlement state.");require(virtualChannels[_vcID].updateVCtimeout<now,"Update vc timeout has not elapsed.");require(!virtualChannels[_vcID].isClose,"VC is already closed");Channels[_lcID].numOpenVC--;virtualChannels[_vcID].isClose=true;if(virtualChannels[_vcID].partyA==Channels[_lcID].partyAddresses[0]){Channels[_lcID].ethBalances[0]+=virtualChannels[_vcID].ethBalances[0];Channels[_lcID].ethBalances[1]+=virtualChannels[_vcID].ethBalances[1];Channels[_lcID].erc20Balances[0]+=virtualChannels[_vcID].erc20Balances[0];Channels[_lcID].erc20Balances[1]+=virtualChannels[_vcID].erc20Balances[1];}elseif(virtualChannels[_vcID].partyB==Channels[_lcID].partyAddresses[0]){Channels[_lcID].ethBalances[0]+=virtualChannels[_vcID].ethBalances[1];Channels[_lcID].ethBalances[1]+=virtualChannels[_vcID].ethBalances[0];Channels[_lcID].erc20Balances[0]+=virtualChannels[_vcID].erc20Balances[1];Channels[_lcID].erc20Balances[1]+=virtualChannels[_vcID].erc20Balances[0];}emitDidVCClose(_lcID,_vcID,virtualChannels[_vcID].erc20Balances[0],virtualChannels[_vcID].erc20Balances[1]);}functionbyzantineCloseChannel(bytes32_lcID)public{Channelstoragechannel=Channels[_lcID];require(channel.isOpen,"Channel is not open");require(channel.isUpdateLCSettling==true);require(channel.numOpenVC==0);require(channel.updateLCtimeout<now,"LC timeout over.");uint256totalEthDeposit=channel.initialDeposit[0]+channel.ethBalances[2]+channel.ethBalances[3];uint256totalTokenDeposit=channel.initialDeposit[1]+channel.erc20Balances[2]+channel.erc20Balances[3];uint256possibleTotalEthBeforeDeposit=channel.ethBalances[0]+channel.ethBalances[1];uint256possibleTotalTokenBeforeDeposit=channel.erc20Balances[0]+channel.erc20Balances[1];if(possibleTotalEthBeforeDeposit<totalEthDeposit){channel.ethBalances[0]+=channel.ethBalances[2];channel.ethBalances[1]+=channel.ethBalances[3];}else{require(possibleTotalEthBeforeDeposit==totalEthDeposit);}if(possibleTotalTokenBeforeDeposit<totalTokenDeposit){channel.erc20Balances[0]+=channel.erc20Balances[2];channel.erc20Balances[1]+=channel.erc20Balances[3];}else{require(possibleTotalTokenBeforeDeposit==totalTokenDeposit);}uint256ethbalanceA=channel.ethBalances[0];uint256ethbalanceI=channel.ethBalances[1];uint256tokenbalanceA=channel.erc20Balances[0];uint256tokenbalanceI=channel.erc20Balances[1];channel.ethBalances[0]=0;channel.ethBalances[1]=0;channel.erc20Balances[0]=0;channel.erc20Balances[1]=0;if(ethbalanceA!=0||ethbalanceI!=0){channel.partyAddresses[0].transfer(ethbalanceA);channel.partyAddresses[1].transfer(ethbalanceI);}if(tokenbalanceA!=0||tokenbalanceI!=0){require(channel.token.transfer(channel.partyAddresses[0],tokenbalanceA),"byzantineCloseChannel: token transfer failure");require(channel.token.transfer(channel.partyAddresses[1],tokenbalanceI),"byzantineCloseChannel: token transfer failure");}channel.isOpen=false;numChannels--;emitDidLCClose(_lcID,channel.sequence,ethbalanceA,ethbalanceI,tokenbalanceA,tokenbalanceI);}function_isContained(bytes32_hash,bytes_proof,bytes32_root)internalpurereturns(bool){bytes32cursor=_hash;bytes32proofElem;for(uint256i=64;i<=_proof.length;i+=32){if(cursor<proofElem){cursor=keccak256(abi.encodePacked(cursor,proofElem));}else{cursor=keccak256(abi.encodePacked(proofElem,cursor));}}returncursor==_root;}functiongetChannel(bytes32id)publicviewreturns(address[2],uint256[4],uint256[4],uint256[2],uint256,uint256,bytes32,uint256,uint256,bool,bool,uint256){Channelmemorychannel=Channels[id];return(channel.partyAddresses,channel.ethBalances,channel.erc20Balances,channel.initialDeposit,channel.sequence,channel.confirmTime,channel.VCrootHash,channel.LCopenTimeout,channel.updateLCtimeout,channel.isOpen,channel.isUpdateLCSettling,channel.numOpenVC);}functiongetVirtualChannel(bytes32id)publicviewreturns(bool,bool,uint256,address,uint256,address,address,address,uint256[2],uint256[2],uint256[2]){VirtualChannelmemoryvirtualChannel=virtualChannels[id];return(virtualChannel.isClose,virtualChannel.isInSettlementState,virtualChannel.sequence,virtualChannel.challenger,virtualChannel.updateVCtimeout,virtualChannel.partyA,virtualChannel.partyB,virtualChannel.partyI,virtualChannel.ethBalances,virtualChannel.erc20Balances,virtualChannel.bond);}}<EOF>